/**
 * \file col.c
 * Automatic pretty printing in columns.
 * Author: Bernhard von Stengel  stengel@maths.lse.ac.uk 17 Apr 2000
 */

#include <stdio.h>
#include <stdlib.h>
        /* malloc, calloc, atoi         */
#include <stddef.h>
        /* typedef unsigned size_t;     */
#include <string.h>
        /* strcmp, strlen               */

#include "col.h"

/* contains in succession all strings generated by  colpr,
 * each terminated by '\0'
 */
static char buf[COLBUFSIZE];

static int posinbuf;    /* first free byte is  buf[posinbuf]    */
static int ncols;       /* number of columns                    */
static int *colwidth;   /* [0..ncols-1]  output widths          */
static int *widthsign;  /* -1 for left, 1 for right adjustment  */
static int currlines;   /* no of fully printed lines            */
static int currcol;     /* current column, modulo  ncols        */

/* --------- routines ----------------------------------------- */
void colset(int c)
{
    int j;
    if (c < 1)
        {
        fprintf(stderr, "colset  requires positive no of cols, not %d\n", c);
        fprintf(stderr, "Emergency stop.\n");
        exit(1);
        }
    if (ncols)      /* allocation has taken place before    */
        /* free space of previously allocated arrays        */
        {
        free(colwidth);
        free(widthsign);
        }
    colwidth = (int *) calloc(c, sizeof(int));      /* init to  0   */
    widthsign = (int *) calloc(c, sizeof(int));
    if (widthsign == NULL)
        {
        fprintf(stderr, "colset  is out of memory for %d columns.\n", c);
        fprintf(stderr, "Emergency stop.\n");
        exit(1);
        }
    for (j=0; j < c; j++)
        widthsign[j] = 1;
    ncols = c;
    posinbuf = 0;
    currcol = 0;
    currlines = 0;
}

void colipr(int i)
{
    char s[ISTR];
    sprintf(s, "%d", i);
    colpr(s);
}

void colleft(int c)
        /* making column  c  in  0..ncols-1  left-adjusted      */
{
    widthsign[c] = -1;
}

/* print the first  cols  strings starting at  s  
 * followed by "\n".  Print nothing if  cols==0. 
 * return pointer to the next position. 
 */
static char * prline (char *s, int cols)
{
    int j;
    for (j=0; j < cols; j++)
        {
        printf("%*s", colwidth[j] * widthsign[j], s);
        s += strlen(s) + 1;
        if (j < cols - 1)   /* avoid trailing blanks in line        */
            printf(" ");    /* more sophisticated spacing possible  */
        else
            printf("\n");   /* in loop to prevent newline if 0 cols */
        }
    return s;
}

void colout(void)
{
    int i;
    char *s;
    s = buf; 
    for (i=0; i < currlines; i++)
         s = prline(s, ncols);
    prline(s, currcol);
}

void colpr(const char *s)
{
    int j;
    int w = strlen(s);
    
    if (posinbuf + w + 1 > COLBUFSIZE)
        /* not enough space in current buffer, flush                */
        /* require  w < COLBUFSIZE,  otherwise undefined behavior   */
        {
        int cc = currcol;
        colout();
        printf("\n-----output reset-----\n\n");
        colset(ncols);
        for (j=0; j < cc; j++)
            /* print blank columns to continue in the correct column  */
            buf[posinbuf++] = '\0';
        currcol = cc;
        }
    if (colwidth[currcol] < w)
        colwidth[currcol] = w;
    strcpy(&buf[posinbuf], s);
    posinbuf += w + 1;
    currcol++;
    if (currcol==ncols)     /* this requires  ncols > 0     */
        {
        currcol = 0;
        currlines++;
        }
}

void colnl(void)
{
    int j;
    for (j=currcol; j < ncols; j++)
         colpr("");
}
